<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Arg` struct in crate `clap`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Arg">

    <title>clap::Arg - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>clap</a></p><script>window.sidebarCurrent = {name: 'Arg', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>clap</a>::<wbr><a class='struct' href=''>Arg</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-3013' class='srclink' href='../src/clap/args/arg.rs.html#35-78' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Arg&lt;'a,&nbsp;'b&gt; <span class='where'>where 'a: 'b</span> {
    // some fields omitted
}</pre><div class='docblock'><p>The abstract representation of a command line argument. Used to set all the options and
relationships that define a valid argument for the program.</p>

<p>There are two methods for constructing <a href="./struct.Arg.html"><code>Arg</code></a>s, using the builder pattern and setting options
manually, or using a usage string which is far less verbose but has fewer options. You can also
use a combination of the two methods to achieve the best of both worlds.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Using the traditional builder pattern and setting each option manually</span>
<span class='kw'>let</span> <span class='ident'>cfg</span> <span class='op'>=</span> <span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
      .<span class='ident'>short</span>(<span class='string'>&quot;c&quot;</span>)
      .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
      .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
      .<span class='ident'>value_name</span>(<span class='string'>&quot;FILE&quot;</span>)
      .<span class='ident'>help</span>(<span class='string'>&quot;Provides a config file to myprog&quot;</span>);
<span class='comment'>// Using a usage string (setting a similar argument to the one above)</span>
<span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-i, --input=[FILE] &#39;Provides an input file to the program&#39;&quot;</span>);</pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl&lt;'a,&nbsp;'b&gt; <a class='struct' href='../clap/struct.Arg.html' title='clap::Arg'>Arg</a>&lt;'a,&nbsp;'b&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-3040' class='srclink' href='../src/clap/args/arg.rs.html#108-2354' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.with_name' class='method'><code>fn <a href='#method.with_name' class='fnname'>with_name</a>(n: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Creates a new instance of <a href="./struct.Arg.html"><code>Arg</code></a> using a unique string name. The name will be used to get
information about whether or not the argument was used at runtime, get values, set
relationships with other args, etc..</p>

<p><strong>NOTE:</strong> In the case of arguments that take values (i.e. <a href="./struct.Arg.html#method.takes_value"><code>Arg::takes_value(true)</code></a>)
and positional arguments (i.e. those without a preceding <code>-</code> or <code>--</code>) the name will also
be displayed when the user prints the usage/help information of the program.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)</pre>
</div><h4 id='method.from_usage' class='method'><code>fn <a href='#method.from_usage' class='fnname'>from_usage</a>(u: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Creates a new instance of <a href="./struct.Arg.html"><code>Arg</code></a> from a usage string. Allows creation of basic settings
for the <a href="./struct.Arg.html"><code>Arg</code></a>. The syntax is flexible, but there are some rules to follow.</p>

<p><strong>NOTE</strong>: Not all settings may be set using the usage string method. Some properties are
only available via the builder pattern.</p>

<p><strong>NOTE</strong>: Only ASCII values are officially supported in <a href="./struct.Arg.html#method.from_usage"><code>Arg::from_usage</code></a> strings. Some
UTF-8 codepoints may work just fine, but this is not guaranteed.</p>

<h1 id='syntax' class='section-header'><a href='#syntax'>Syntax</a></h1>
<p>Usage strings typically following the form:</p>

<pre><code class="language-notrust">[explicit name] [short] [long] [value names] [help string]
</code></pre>

<p>This is not a hard rule as the attributes can appear in other orders. There are also
several additional sigils which denote additional settings. Below are the details of each
portion of the string.</p>

<h3 id='explicit-name' class='section-header'><a href='#explicit-name'>Explicit Name</a></h3>
<p>This is an optional field, if it&#39;s omitted the argument will use one of the additional
fields as the name using the following priority order:</p>

<ul>
<li>Explicit Name (This always takes precedence when present)</li>
<li>Long</li>
<li>Short</li>
<li>Value Name</li>
</ul>

<p><code>clap</code> determines explicit names as the first string of characters between either <code>[]</code> or
<code>&lt;&gt;</code> where <code>[]</code> has the dual notation of meaning the argument is optional, and <code>&lt;&gt;</code> meaning
the argument is required.</p>

<p>Explicit names may be followed by:
 * The multiple denotation <code>...</code></p>

<p>Example explicit names as follows (<code>ename</code> for an optional argument, and <code>rname</code> for a
required argument):</p>

<pre><code class="language-notrust">[ename] -s, --long &#39;some flag&#39;
&lt;rname&gt; -r, --longer &#39;some other flag&#39;
</code></pre>

<h3 id='short' class='section-header'><a href='#short'>Short</a></h3>
<p>This is set by placing a single character after a leading <code>-</code>.</p>

<p>Shorts may be followed by
 * The multiple denotation <code>...</code>
 * An optional comma <code>,</code> which is cosmetic only
 * Value notation</p>

<p>Example shorts are as follows (<code>-s</code>, and <code>-r</code>):</p>

<pre><code class="language-notrust">-s, --long &#39;some flag&#39;
&lt;rname&gt; -r [val], --longer &#39;some option&#39;
</code></pre>

<h3 id='long' class='section-header'><a href='#long'>Long</a></h3>
<p>This is set by placing a word (no spaces) after a leading <code>--</code>.</p>

<p>Shorts may be followed by
 * The multiple denotation <code>...</code>
 * Value notation</p>

<p>Example longs are as follows (<code>--some</code>, and <code>--rapid</code>):</p>

<pre><code class="language-notrust">-s, --some &#39;some flag&#39;
--rapid=[FILE] &#39;some option&#39;
</code></pre>

<h3 id='values-value-notation' class='section-header'><a href='#values-value-notation'>Values (Value Notation)</a></h3>
<p>This is set by placing a word(s) between <code>[]</code> or <code>&lt;&gt;</code> optionally after <code>=</code> (although this
is cosmetic only and does not affect functionality). If an explicit name has <strong>not</strong> been
set, using <code>&lt;&gt;</code> will denote a required argument, and <code>[]</code> will denote an optional argument</p>

<p>Values may be followed by
 * The multiple denotation <code>...</code>
 * More Value notation</p>

<p>More than one value will also implicitly set the arguments number of values, i.e. having
two values, <code>--option [val1] [val2]</code> specifies that in order for option to be satisified it
must receive exactly two values</p>

<p>Example values are as follows (<code>FILE</code>, and <code>SPEED</code>):</p>

<pre><code class="language-notrust">-s, --some [FILE] &#39;some option&#39;
--rapid=&lt;SPEED&gt;... &#39;some required multiple option&#39;
</code></pre>

<h3 id='help-string' class='section-header'><a href='#help-string'>Help String</a></h3>
<p>The help string is denoted between a pair of single quotes <code>&#39;&#39;</code> and may contain any
characters.</p>

<p>Example help strings are as follows:</p>

<pre><code class="language-notrust">-s, --some [FILE] &#39;some option&#39;
--rapid=&lt;SPEED&gt;... &#39;some required multiple option&#39;
</code></pre>

<h3 id='additional-sigils' class='section-header'><a href='#additional-sigils'>Additional Sigils</a></h3>
<p>Multiple notation <code>...</code> (three consecutive dots/periods) specifies that this argument may
be used multiple times. Do not confuse multiple occurrences (<code>...</code>) with multiple values.
<code>--option val1 val2</code> is a single occurrence with multiple values. <code>--flag --flag</code> is
multiple occurrences (and then you can obviously have instances of both as well)</p>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;myprog&quot;</span>)
    .<span class='ident'>args</span>(<span class='kw-2'>&amp;</span>[
        <span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;--config &lt;FILE&gt; &#39;a required file for the configuration and no short&#39;&quot;</span>),
        <span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-d, --debug... &#39;turns on debugging information and allows multiples&#39;&quot;</span>),
        <span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;[input] &#39;an optional input file to use&#39;&quot;</span>)
])</pre>
</div><h4 id='method.short' class='method'><code>fn <a href='#method.short' class='fnname'>short</a>&lt;S:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;&gt;(self, s: S) -&gt; Self</code></h4>
<div class='docblock'><p>Sets the short version of the argument without the preceding <code>-</code>.</p>

<p>By default <code>clap</code> automatically assigns <code>V</code> and <code>h</code> to the auto-generated <code>version</code> and
<code>help</code> arguments respectively. You may use the uppercase <code>V</code> or lowercase <code>h</code> for your own
arguments, in which case <code>clap</code> simply will not assign those to the auto-generated
<code>version</code> or <code>help</code> arguments.</p>

<p><strong>NOTE:</strong> Any leading <code>-</code> characters will be stripped, and only the first
non <code>-</code> character will be used as the <a href="./struct.Arg.html#method.short"><code>short</code></a> version</p>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<p>To set <a href="./struct.Arg.html#method.short"><code>short</code></a> use a single valid UTF-8 code point. If you supply a leading <code>-</code> such as
<code>-c</code>, the <code>-</code> will be stripped.</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>short</span>(<span class='string'>&quot;c&quot;</span>)</pre>

<p>Setting <a href="./struct.Arg.html#method.short"><code>short</code></a> allows using the argument via a single hyphen (<code>-</code>) such as <code>-c</code></p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;shorttest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;c&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;shorttest&quot;</span>, <span class='string'>&quot;-c&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;config&quot;</span>));</pre>
</div><h4 id='method.long' class='method'><code>fn <a href='#method.long' class='fnname'>long</a>(self, l: &amp;'b <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets the long version of the argument without the preceding <code>--</code>.</p>

<p>By default <code>clap</code> automatically assigns <code>version</code> and <code>help</code> to the auto-generated
<code>version</code> and <code>help</code> arguments respectively. You may use the word <code>version</code> or <code>help</code> for
the long form of your own arguments, in which case <code>clap</code> simply will not assign those to
the auto-generated <code>version</code> or <code>help</code> arguments.</p>

<p><strong>NOTE:</strong> Any leading <code>-</code> characters will be stripped</p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<p>To set <code>long</code> use a word containing valid UTF-8 codepoints. If you supply a double leading
<code>--</code> such as <code>--config</code> they will be stripped. Hyphens in the middle of the word, however,
will <em>not</em> be stripped (i.e. <code>config-file</code> is allowed)</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
    .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)</pre>

<p>Setting <code>long</code> allows using the argument via a double hyphen (<code>--</code>) such as <code>--config</code></p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;longtest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;longtest&quot;</span>, <span class='string'>&quot;--config&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;cfg&quot;</span>));</pre>
</div><h4 id='method.help' class='method'><code>fn <a href='#method.help' class='fnname'>help</a>(self, h: &amp;'b <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets the help text of the argument that will be displayed to the user when they print the
usage/help information.</p>

<h1 id='examples-5' class='section-header'><a href='#examples-5'>Examples</a></h1>
<p>Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to
include a newline in the help text and have the following text be properly aligned with all
the other help text. To include a newline <strong>and</strong> be properly aligned with all other
arguments help text, it must be specified via a tag inside curly braces, like so <code>{n}</code>.
Using the standard <code>\n</code> will produce a newline, but it will not be properly aligned.</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>help</span>(<span class='string'>&quot;The config file used by the myprog&quot;</span>)</pre>

<p>Setting <code>help</code> displays a short message to the side of the argument when the user passes
<code>-h</code> or <code>--help</code> (by default).</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;helptest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>help</span>(<span class='string'>&quot;Some help text describing the --config arg&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;shorttest&quot;</span>, <span class='string'>&quot;--help&quot;</span>
    ]);</pre>

<p>The above example displays</p>

<pre><code class="language-notrust">helptest

USAGE:
   helptest [FLAGS]

FLAGS:
    --config     Some help text describing the --config arg
-h, --help       Prints help information
-V, --version    Prints version information
</code></pre>
</div><h4 id='method.required' class='method'><code>fn <a href='#method.required' class='fnname'>required</a>(self, r: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets whether or not the argument is required by default. Required by default means it is
required, when no other conflicting rules have been evaluated. Conflicting rules take
precedence over being required. <strong>Default:</strong> <code>false</code></p>

<p><strong>NOTE:</strong> Flags (i.e. not positional, or arguments that take values) cannot be required by
default. This is simply because if a flag should be required, it should simply be implied
as no additional information is required from user. Flags by their very nature are simply
yes/no, or true/false.</p>

<h1 id='examples-6' class='section-header'><a href='#examples-6'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>required</span>(<span class='bool-val'>true</span>)</pre>

<p>Setting <a href="./struct.Arg.html#method.required"><code>Arg::required(true)</code></a> requires that the argument be used at runtime.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;longtest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;shorttest&quot;</span>, <span class='string'>&quot;--config&quot;</span>, <span class='string'>&quot;file.conf&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>());</pre>

<p>Setting <a href="./struct.Arg.html#method.required"><code>Arg::required(true)</code></a> and <em>not</em> supplying that argument is an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;longtest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;shorttest&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>MissingRequiredArgument</span>);</pre>
</div><h4 id='method.required_unless' class='method'><code>fn <a href='#method.required_unless' class='fnname'>required_unless</a>(self, name: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets an arg that override this arg&#39;s required setting. (i.e. this arg will be required
unless this other argument is present).</p>

<p><strong>Pro Tip:</strong> Using <a href="./struct.Arg.html#method.required_unless"><code>Arg::required_unless</code></a> implies <a href="./struct.Arg.html#method.required"><code>Arg::required</code></a> and is therefore not
mandatory to also set.</p>

<h1 id='examples-7' class='section-header'><a href='#examples-7'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>required_unless</span>(<span class='string'>&quot;debug&quot;</span>)</pre>

<p>Setting <a href="./struct.Arg.html#method.required_unless"><code>Arg::required_unless(name)</code></a> requires that the argument be used at runtime
<em>unless</em> <code>name</code> is present. In the following example, the required argument is <em>not</em>
provided, but it&#39;s not an error because the <code>unless</code> arg has been supplied.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;unlesstest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required_unless</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;unlesstest&quot;</span>, <span class='string'>&quot;--debug&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>());</pre>

<p>Setting <a href="./struct.Arg.html#method.required_unless"><code>Arg::required_unless(name)</code></a> and <em>not</em> supplying <code>name</code> or this arg is an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;unlesstest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required_unless</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;unlesstest&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>MissingRequiredArgument</span>);</pre>
</div><h4 id='method.required_unless_all' class='method'><code>fn <a href='#method.required_unless_all' class='fnname'>required_unless_all</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets args that override this arg&#39;s required setting. (i.e. this arg will be required unless
all these other arguments are present).</p>

<p><strong>NOTE:</strong> If you wish for this argument to only be required if <em>one of</em> these args are
present see <a href="./struct.Arg.html#method.required_unless_one"><code>Arg::required_unless_one</code></a></p>

<h1 id='examples-8' class='section-header'><a href='#examples-8'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>required_unless_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;cfg&quot;</span>, <span class='string'>&quot;dbg&quot;</span>])</pre>

<p>Setting <a href="./struct.Arg.html#method.required_unless_all"><code>Arg::required_unless_all(names)</code></a> requires that the argument be used at runtime
<em>unless</em> <em>all</em> the args in <code>names</code> are present. In the following example, the required
argument is <em>not</em> provided, but it&#39;s not an error because all the <code>unless</code> args have been
supplied.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;unlessall&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required_unless_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;dbg&quot;</span>, <span class='string'>&quot;infile&quot;</span>])
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;infile&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;i&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;unlessall&quot;</span>, <span class='string'>&quot;--debug&quot;</span>, <span class='string'>&quot;-i&quot;</span>, <span class='string'>&quot;file&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>());</pre>

<p>Setting <a href="./struct.Arg.html#method.required_unless_all"><code>Arg::required_unless_all(names)</code></a> and <em>not</em> supplying <em>all</em> of <code>names</code> or this
arg is an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;unlessall&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required_unless_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;dbg&quot;</span>, <span class='string'>&quot;infile&quot;</span>])
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;infile&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;i&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;unlessall&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>MissingRequiredArgument</span>);</pre>
</div><h4 id='method.required_unless_one' class='method'><code>fn <a href='#method.required_unless_one' class='fnname'>required_unless_one</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets args that override this arg&#39;s <a href="./struct.Arg.html#method.required">required</a> setting. (i.e. this arg will be required
unless <em>at least one of</em> these other arguments are present).</p>

<p><strong>NOTE:</strong> If you wish for this argument to only be required if <em>all of</em> these args are
present see <a href="./struct.Arg.html#method.required_unless_all"><code>Arg::required_unless_all</code></a></p>

<h1 id='examples-9' class='section-header'><a href='#examples-9'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>required_unless_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;cfg&quot;</span>, <span class='string'>&quot;dbg&quot;</span>])</pre>

<p>Setting <a href="./struct.Arg.html#method.required_unless_one"><code>Arg::required_unless_one(names)</code></a> requires that the argument be used at runtime
<em>unless</em> <em>at least one of</em> the args in <code>names</code> are present. In the following example, the
required argument is <em>not</em> provided, but it&#39;s not an error because one the <code>unless</code> args
have been supplied.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;unlessone&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required_unless_one</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;dbg&quot;</span>, <span class='string'>&quot;infile&quot;</span>])
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;infile&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;i&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;unlessone&quot;</span>, <span class='string'>&quot;--debug&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>());</pre>

<p>Setting <a href="./struct.Arg.html#method.required_unless_one"><code>Arg::required_unless_one(names)</code></a> and <em>not</em> supplying <em>at least one of</em> <code>names</code>
or this arg is an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;unlessone&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>required_unless_one</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;dbg&quot;</span>, <span class='string'>&quot;infile&quot;</span>])
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;dbg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;infile&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;i&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;unlessone&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>MissingRequiredArgument</span>);</pre>
</div><h4 id='method.conflicts_with' class='method'><code>fn <a href='#method.conflicts_with' class='fnname'>conflicts_with</a>(self, name: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets a conflicting argument by name. I.e. when using this argument,
the following argument can&#39;t be present and vice versa.</p>

<p><strong>NOTE:</strong> Conflicting rules take precedence over being required by default. Conflict rules
only need to be set for one of the two arguments, they do not need to be set for each.</p>

<p><strong>NOTE:</strong> Defining a conflict is two-way, but does <em>not</em> need to defined for both arguments
(i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need
need to also do B.conflicts_with(A))</p>

<h1 id='examples-10' class='section-header'><a href='#examples-10'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>conflicts_with</span>(<span class='string'>&quot;debug&quot;</span>)</pre>

<p>Setting conflicting argument, and having both arguments present at runtime is an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;conflictions&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>conflicts_with</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;conflictions&quot;</span>, <span class='string'>&quot;--debug&quot;</span>, <span class='string'>&quot;--config&quot;</span>, <span class='string'>&quot;file.conf&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>ArgumentConflict</span>);</pre>
</div><h4 id='method.conflicts_with_all' class='method'><code>fn <a href='#method.conflicts_with_all' class='fnname'>conflicts_with_all</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>The same as <a href="./struct.Arg.html#method.conflicts_with"><code>Arg::conflicts_with</code></a> but allows specifying multiple two-way conlicts per
argument.</p>

<p><strong>NOTE:</strong> Conflicting rules take precedence over being required by default. Conflict rules
only need to be set for one of the two arguments, they do not need to be set for each.</p>

<p><strong>NOTE:</strong> Defining a conflict is two-way, but does <em>not</em> need to defined for both arguments
(i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need
need to also do B.conflicts_with(A))</p>

<h1 id='examples-11' class='section-header'><a href='#examples-11'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>conflicts_with_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;debug&quot;</span>, <span class='string'>&quot;input&quot;</span>])</pre>

<p>Setting conflicting argument, and having any of the arguments present at runtime with a
conflicting argument is an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;conflictions&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>conflicts_with_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;debug&quot;</span>, <span class='string'>&quot;input&quot;</span>])
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;conflictions&quot;</span>, <span class='string'>&quot;--config&quot;</span>, <span class='string'>&quot;file.conf&quot;</span>, <span class='string'>&quot;file.txt&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>ArgumentConflict</span>);</pre>
</div><h4 id='method.overrides_with' class='method'><code>fn <a href='#method.overrides_with' class='fnname'>overrides_with</a>(self, name: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets a overridable argument by name. I.e. this argument and the following argument
will override each other in POSIX style (whichever argument was specified at runtime
<strong>last</strong> &quot;wins&quot;)</p>

<p><strong>NOTE:</strong> When an argument is overridden it is essentially as if it never was used, any
conflicts, requirements, etc. are evaluated <strong>after</strong> all &quot;overrides&quot; have been removed</p>

<h1 id='examples-12' class='section-header'><a href='#examples-12'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posix&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-f, --flag &#39;some flag&#39;&quot;</span>)
        .<span class='ident'>conflicts_with</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-d, --debug &#39;other flag&#39;&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-c, --color &#39;third flag&#39;&quot;</span>)
        .<span class='ident'>overrides_with</span>(<span class='string'>&quot;flag&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posix&quot;</span>, <span class='string'>&quot;-f&quot;</span>, <span class='string'>&quot;-d&quot;</span>, <span class='string'>&quot;-c&quot;</span>]);
                                <span class='comment'>//    ^~~~~~~~~~~~^~~~~ flag is overridden by color</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;color&quot;</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;debug&quot;</span>)); <span class='comment'>// even though flag conflicts with debug, it&#39;s as if flag</span>
                                <span class='comment'>// was never used because it was overridden with color</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;flag&quot;</span>));</pre>
</div><h4 id='method.overrides_with_all' class='method'><code>fn <a href='#method.overrides_with_all' class='fnname'>overrides_with_all</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets multiple mutually overridable arguments by name. I.e. this argument and the following
argument will override each other in POSIX style (whichever argument was specified at
runtime <strong>last</strong> &quot;wins&quot;)</p>

<p><strong>NOTE:</strong> When an argument is overridden it is essentially as if it never was used, any
conflicts, requirements, etc. are evaluated <strong>after</strong> all &quot;overrides&quot; have been removed</p>

<h1 id='examples-13' class='section-header'><a href='#examples-13'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posix&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-f, --flag &#39;some flag&#39;&quot;</span>)
        .<span class='ident'>conflicts_with</span>(<span class='string'>&quot;color&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-d, --debug &#39;other flag&#39;&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>from_usage</span>(<span class='string'>&quot;-c, --color &#39;third flag&#39;&quot;</span>)
        .<span class='ident'>overrides_with_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;flag&quot;</span>, <span class='string'>&quot;debug&quot;</span>]))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posix&quot;</span>, <span class='string'>&quot;-f&quot;</span>, <span class='string'>&quot;-d&quot;</span>, <span class='string'>&quot;-c&quot;</span>]);
                                <span class='comment'>//    ^~~~~~^~~~~~~~~ flag and debug are overridden by color</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;color&quot;</span>)); <span class='comment'>// even though flag conflicts with color, it&#39;s as if flag</span>
                                <span class='comment'>// and debug were never used because they were overridden</span>
                                <span class='comment'>// with color</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;debug&quot;</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;flag&quot;</span>));</pre>
</div><h4 id='method.requires' class='method'><code>fn <a href='#method.requires' class='fnname'>requires</a>(self, name: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets an argument by name that is required when this one is present I.e. when
using this argument, the following argument <em>must</em> be present.</p>

<p><strong>NOTE:</strong> <a href="./struct.Arg.html#method.conflicts_with">Conflicting</a> rules and <a href="./struct.Arg.html#method.overrides_with">override</a> rules take precedence over being required</p>

<h1 id='examples-14' class='section-header'><a href='#examples-14'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>requires</span>(<span class='string'>&quot;input&quot;</span>)</pre>

<p>Setting <a href="./struct.Arg.html#method.requires"><code>Arg::requires(name)</code></a> requires that the argument be used at runtime if the
defining argument is used. If the defining argument isn&#39;t used, the other argument isn&#39;t
required</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;reqtest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>requires</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;reqtest&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>()); <span class='comment'>// We didn&#39;t use cfg, so input wasn&#39;t required</span></pre>

<p>Setting <a href="./struct.Arg.html#method.requires"><code>Arg::requires(name)</code></a> and <em>not</em> supplying that argument is an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;reqtest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>requires</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;reqtest&quot;</span>, <span class='string'>&quot;--config&quot;</span>, <span class='string'>&quot;file.conf&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>MissingRequiredArgument</span>);</pre>
</div><h4 id='method.requires_all' class='method'><code>fn <a href='#method.requires_all' class='fnname'>requires_all</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets multiple arguments by names that are required when this one is present I.e. when
using this argument, the following arguments <em>must</em> be present.</p>

<p><strong>NOTE:</strong> <a href="./struct.Arg.html#method.conflicts_with">Conflicting</a> rules and <a href="./struct.Arg.html#method.overrides_with">override</a> rules take precedence over being required
by default.</p>

<h1 id='examples-15' class='section-header'><a href='#examples-15'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>requires_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;input&quot;</span>, <span class='string'>&quot;output&quot;</span>])</pre>

<p>Setting [<code>Arg::requires_all(&amp;[arg, arg2])</code>] requires that all the arguments be used at
runtime if the defining argument is used. If the defining argument isn&#39;t used, the other
argument isn&#39;t required</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;reqtest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>requires</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;output&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>2</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;reqtest&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>()); <span class='comment'>// We didn&#39;t use cfg, so input and output weren&#39;t required</span></pre>

<p>Setting [<code>Arg::requires_all(&amp;[arg, arg2])</code>] and <em>not</em> supplying all the arguments is an
error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;reqtest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>requires_all</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;input&quot;</span>, <span class='string'>&quot;output&quot;</span>])
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;input&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;output&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>2</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;reqtest&quot;</span>, <span class='string'>&quot;--config&quot;</span>, <span class='string'>&quot;file.conf&quot;</span>, <span class='string'>&quot;in.txt&quot;</span>
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='comment'>// We didn&#39;t use output</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>MissingRequiredArgument</span>);</pre>

<p>[<code>Arg::requires_all(&amp;[arg, arg2])</code>]: ./struct.Arg.html#method.requires_all</p>
</div><h4 id='method.takes_value' class='method'><code>fn <a href='#method.takes_value' class='fnname'>takes_value</a>(self, tv: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies that the argument takes a value at run time.</p>

<p><strong>NOTE:</strong> values for arguments may be specified in any of the following methods</p>

<ul>
<li>Using a space such as <code>-o value</code> or <code>--option value</code></li>
<li>Using an equals and no space such as <code>-o=value</code> or <code>--option=value</code></li>
<li>Use a short and no space such as <code>-ovalue</code></li>
</ul>

<p><strong>NOTE:</strong> By default, args which allow <a href="./struct.Arg.html#method.multiple">multiple values</a> are delimited by commas, meaning
<code>--option=val1,val2,val3</code> is three values for the <code>--option</code> argument. If you wish to
change the delimiter to another character you can use <a href="./struct.Arg.html#method.value_delimiter"><code>Arg::value_delimiter(char)</code></a>,
alternatively you can turn delimiting values <strong>OFF</strong> by using <a href="./struct.Arg.html#method.use_delimiter"><code>Arg::use_delimiter(false)</code></a></p>

<h1 id='examples-16' class='section-header'><a href='#examples-16'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)</pre>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posvals&quot;</span>, <span class='string'>&quot;--mode&quot;</span>, <span class='string'>&quot;fast&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;mode&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;mode&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;fast&quot;</span>));</pre>
</div><h4 id='method.index' class='method'><code>fn <a href='#method.index' class='fnname'>index</a>(self, idx: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the index of a positional argument <strong>starting at</strong> 1.</p>

<p><strong>NOTE:</strong> The index refers to position according to <strong>other positional argument</strong>. It does
not define position in the argument list as a whole.</p>

<p><strong>NOTE:</strong> If no <a href="./struct.Arg.html#method.short"><code>Arg::short</code></a>, or <a href="./struct.Arg.html#method.long"><code>Arg::long</code></a> have been defined, you can optionally
leave off the <code>index</code> method, and the index will be assigned in order of evaluation.
Utilizing the <code>index</code> method allows for setting indexes out of order</p>

<p><strong>NOTE:</strong> When utilized with <a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a>, only the <strong>last</strong> positional argument
may be defined as multiple (i.e. with the highest index)</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Although not in this method directly, <a href="./struct.App.html"><code>App</code></a> will <a href="https://doc.rust-lang.org/std/macro.panic!.html"><code>panic!</code></a> if indexes are skipped (such
as defining <code>index(1)</code> and <code>index(3)</code> but not <code>index(2)</code>, or a positional argument is
defined as multiple and is not the highest index</p>

<h1 id='examples-17' class='section-header'><a href='#examples-17'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>index</span>(<span class='number'>1</span>)</pre>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posvals&quot;</span>, <span class='string'>&quot;--debug&quot;</span>, <span class='string'>&quot;fast&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;mode&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;mode&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;fast&quot;</span>)); <span class='comment'>// notice index(1) means &quot;first positional&quot;</span>
                                              <span class='comment'>// *not* first argument</span></pre>
</div><h4 id='method.multiple' class='method'><code>fn <a href='#method.multiple' class='fnname'>multiple</a>(self, multi: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies that the argument may appear more than once. For flags, this results
in the number of occurrences of the flag being recorded. For example <code>-ddd</code> or <code>-d -d -d</code>
would count as three occurrences. For options there is a distinct difference in multiple
occurrences vs multiple values.</p>

<p>For example, <code>--opt val1 val2</code> is one occurrence, but two values. Whereas
<code>--opt val1 --opt val2</code> is two occurrences.</p>

<p><strong>WARNING:</strong></p>

<p>Setting <code>multiple(true)</code> for an <a href="./struct.Arg.html#method.takes_value">option</a> with no other details, allows multiple values
<strong>and</strong> multiple occurrences because it isn&#39;t possible to have more occurrences than values for
options. Because multiple values are allowed, <code>--option val1 val2 val3</code> is perfectly valid,
be careful when designing a CLI where positional arguments are expected after a option which
accepts multiple values, as <code>clap</code> will continue parsing <em>values</em> until it reaches the max
or specific number of values defined, or another flag or option.</p>

<p><strong>Pro Tip</strong>:</p>

<p>It&#39;s possible to define an option which allows multiple occurrences, but only one value per
occurrence. To do this use <a href="./struct.Arg.html#method.number_of_values"><code>Arg::number_of_values(1)</code></a> in coordination with
<a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a>.</p>

<h1 id='examples-18' class='section-header'><a href='#examples-18'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
    .<span class='ident'>short</span>(<span class='string'>&quot;d&quot;</span>)
    .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)</pre>

<p>An example with flags</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;mults&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;verbose&quot;</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;v&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-v&quot;</span>, <span class='string'>&quot;-v&quot;</span>, <span class='string'>&quot;-v&quot;</span>]); <span class='comment'>// note, -vvv would have same result</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;verbose&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;verbose&quot;</span>), <span class='number'>3</span>);</pre>

<p>An example with options</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;mults&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;file&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;file&quot;</span>), <span class='number'>1</span>); <span class='comment'>// notice only one occurrence</span>
<span class='kw'>let</span> <span class='ident'>files</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;file&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>files</span>, [<span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);</pre>

<p>This is functionally equivilant to the example above</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;mults&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);
<span class='kw'>let</span> <span class='ident'>files</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;file&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>files</span>, [<span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;file&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;file&quot;</span>), <span class='number'>3</span>); <span class='comment'>// Notice 3 occurrences</span>
<span class='kw'>let</span> <span class='ident'>files</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;file&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>files</span>, [<span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);</pre>

<p>A common mistake is to define an option which allows multiples, and a positional argument</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;mults&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;word&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>, <span class='string'>&quot;word&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;file&quot;</span>));
<span class='kw'>let</span> <span class='ident'>files</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;file&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>files</span>, [<span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>, <span class='string'>&quot;word&quot;</span>]); <span class='comment'>// wait...what?!</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;word&quot;</span>)); <span class='comment'>// but we clearly used word!</span></pre>

<p>The problem is clap doesn&#39;t know when to stop parsing values for &quot;files&quot;. This is further
compounded by if we&#39;d said <code>word -F file1 file2</code> it would have worked fine, so it would
appear to only fail sometimes...not good!</p>

<p>A solution for the example above is to specify that <code>-F</code> only accepts one value, but is
allowed to appear multiple times</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;mults&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>number_of_values</span>(<span class='number'>1</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;word&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file3&quot;</span>, <span class='string'>&quot;word&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;file&quot;</span>));
<span class='kw'>let</span> <span class='ident'>files</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;file&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>files</span>, [<span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;word&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;word&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;word&quot;</span>));</pre>

<p>As a final example, notice if we define <a href="./struct.Arg.html#method.number_of_values"><code>Arg::number_of_values(1)</code></a> and try to run the
problem example above, it would have been a runtime error with a pretty message to the
user :)</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;mults&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>number_of_values</span>(<span class='number'>1</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;word&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>, <span class='string'>&quot;word&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>UnknownArgument</span>);</pre>
</div><h4 id='method.global' class='method'><code>fn <a href='#method.global' class='fnname'>global</a>(self, g: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies that an argument can be matched to all child <a href="./struct.SubCommand.html"><code>SubCommand</code></a>s.</p>

<p><strong>NOTE:</strong> Global arguments <em>only</em> propagate down, <strong>not</strong> up (to parent commands)</p>

<p><strong>NOTE:</strong> Global arguments <em>cannot</em> be <a href="./struct.Arg.html#method.required">required</a>.</p>

<p><strong>NOTE:</strong> Global arguments, when matched, <em>only</em> exist in the command&#39;s matches that they
were matched to. For example, if you defined a <code>--flag</code> global argument in the top most
parent command, but the user supplied the arguments <code>top cmd1 cmd2 --flag</code> <em>only</em> <code>cmd2</code>&#39;s
<a href="./struct.ArgMatches.html"><code>ArgMatches</code></a> would return <code>true</code> if tested for <a href="./struct.ArgMatches.html#method.is_present"><code>ArgMatches::is_present(&quot;flag&quot;)</code></a>.</p>

<h1 id='examples-19' class='section-header'><a href='#examples-19'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
    .<span class='ident'>short</span>(<span class='string'>&quot;d&quot;</span>)
    .<span class='ident'>global</span>(<span class='bool-val'>true</span>)</pre>

<p>For example, assume an appliction with two subcommands, and you&#39;d like to define a
<code>--verbose</code> flag that can be called on any of the subcommands and parent, but you don&#39;t
want to clutter the source with three duplicate <a href="./struct.Arg.html"><code>Arg</code></a> definitions.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;mults&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;verb&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;verbose&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;v&quot;</span>)
        .<span class='ident'>global</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>subcommand</span>(<span class='ident'>SubCommand</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;test&quot;</span>))
    .<span class='ident'>subcommand</span>(<span class='ident'>SubCommand</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;do-stuff&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;do-stuff&quot;</span>, <span class='string'>&quot;--verbose&quot;</span>]);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>subcommand_name</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&quot;do-stuff&quot;</span>));
<span class='kw'>let</span> <span class='ident'>sub_m</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>subcommand_matches</span>(<span class='string'>&quot;do-stuff&quot;</span>).<span class='ident'>unwrap</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>sub_m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;verb&quot;</span>));</pre>
</div><h4 id='method.empty_values' class='method'><code>fn <a href='#method.empty_values' class='fnname'>empty_values</a>(self, ev: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Allows an argument to accept explicitly empty values. An empty value must be specified at
the command line with an explicit <code>&quot;&quot;</code>, or <code>&#39;&#39;</code></p>

<p><strong>NOTE:</strong> Defaults to <code>true</code> (Explicitly empty values are allowed)</p>

<p><strong>NOTE:</strong> Implicitly sets <a href="./struct.Arg.html#method.takes_value"><code>Arg::takes_value(true)</code></a> when set to <code>false</code></p>

<h1 id='examples-20' class='section-header'><a href='#examples-20'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
    .<span class='ident'>long</span>(<span class='string'>&quot;file&quot;</span>)
    .<span class='ident'>empty_values</span>(<span class='bool-val'>false</span>)</pre>

<p>The default is to allow empty values, such as <code>--option &quot;&quot;</code> would be an empty value. But
we can change to make empty values become an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;evals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;v&quot;</span>)
        .<span class='ident'>empty_values</span>(<span class='bool-val'>false</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;evals&quot;</span>, <span class='string'>&quot;--config=&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>EmptyValue</span>);</pre>
</div><h4 id='method.hidden' class='method'><code>fn <a href='#method.hidden' class='fnname'>hidden</a>(self, h: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Hides an argument from help message output.</p>

<p><strong>NOTE:</strong> This does <strong>not</strong> hide the argument from usage strings on error</p>

<h1 id='examples-21' class='section-header'><a href='#examples-21'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
    .<span class='ident'>hidden</span>(<span class='bool-val'>true</span>)</pre>

<p>Setting <code>hidden(true)</code> will hide the argument when displaying help text</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;helptest&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>hidden</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>help</span>(<span class='string'>&quot;Some help text describing the --config arg&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;shorttest&quot;</span>, <span class='string'>&quot;--help&quot;</span>
    ]);</pre>

<p>The above example displays</p>

<pre><code class="language-notrust">helptest

USAGE:
   helptest [FLAGS]

FLAGS:
-h, --help       Prints help information
-V, --version    Prints version information
</code></pre>
</div><h4 id='method.possible_values' class='method'><code>fn <a href='#method.possible_values' class='fnname'>possible_values</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'b <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies a list of possible values for this argument. At runtime, <code>clap</code> verifies that
only one of the specified values was used, or fails with an error message.</p>

<p><strong>NOTE:</strong> This setting only applies to <a href="./struct.Arg.html#method.takes_value">options</a> and <a href="./struct.Arg.html#method.index">positional arguments</a></p>

<h1 id='examples-22' class='section-header'><a href='#examples-22'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
    .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
    .<span class='ident'>possible_values</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;fast&quot;</span>, <span class='string'>&quot;slow&quot;</span>, <span class='string'>&quot;medium&quot;</span>])</pre>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>possible_values</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;fast&quot;</span>, <span class='string'>&quot;slow&quot;</span>, <span class='string'>&quot;medium&quot;</span>]))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posvals&quot;</span>, <span class='string'>&quot;--mode&quot;</span>, <span class='string'>&quot;fast&quot;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;mode&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;mode&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;fast&quot;</span>));</pre>

<p>The next example shows a failed parse from using a value which wasn&#39;t defined as one of the
possible values.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>possible_values</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;fast&quot;</span>, <span class='string'>&quot;slow&quot;</span>, <span class='string'>&quot;medium&quot;</span>]))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;myprog&quot;</span>, <span class='string'>&quot;--mode&quot;</span>, <span class='string'>&quot;wrong&quot;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>InvalidValue</span>);</pre>
</div><h4 id='method.possible_value' class='method'><code>fn <a href='#method.possible_value' class='fnname'>possible_value</a>(self, name: &amp;'b <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies a possible value for this argument, one at a time. At runtime, <code>clap</code> verifies
that only one of the specified values was used, or fails with error message.</p>

<p><strong>NOTE:</strong> This setting only applies to <a href="./struct.Arg.html#method.takes_value">options</a> and <a href="./struct.Arg.html#method.index">positional arguments</a></p>

<h1 id='examples-23' class='section-header'><a href='#examples-23'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
    .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
    .<span class='ident'>possible_value</span>(<span class='string'>&quot;fast&quot;</span>)
    .<span class='ident'>possible_value</span>(<span class='string'>&quot;slow&quot;</span>)
    .<span class='ident'>possible_value</span>(<span class='string'>&quot;medium&quot;</span>)</pre>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>possible_value</span>(<span class='string'>&quot;fast&quot;</span>)
        .<span class='ident'>possible_value</span>(<span class='string'>&quot;slow&quot;</span>)
        .<span class='ident'>possible_value</span>(<span class='string'>&quot;medium&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posvals&quot;</span>, <span class='string'>&quot;--mode&quot;</span>, <span class='string'>&quot;fast&quot;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;mode&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;mode&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;fast&quot;</span>));</pre>

<p>The next example shows a failed parse from using a value which wasn&#39;t defined as one of the
possible values.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;posvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;mode&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>possible_value</span>(<span class='string'>&quot;fast&quot;</span>)
        .<span class='ident'>possible_value</span>(<span class='string'>&quot;slow&quot;</span>)
        .<span class='ident'>possible_value</span>(<span class='string'>&quot;medium&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;myprog&quot;</span>, <span class='string'>&quot;--mode&quot;</span>, <span class='string'>&quot;wrong&quot;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>InvalidValue</span>);</pre>
</div><h4 id='method.group' class='method'><code>fn <a href='#method.group' class='fnname'>group</a>(self, name: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the name of the <a href="./struct.ArgGroup.html"><code>ArgGroup</code></a> the argument belongs to.</p>

<h1 id='examples-24' class='section-header'><a href='#examples-24'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
    .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>)
    .<span class='ident'>group</span>(<span class='string'>&quot;mode&quot;</span>)</pre>

<p>Multiple arguments can be a member of a single group and then the group checked as if it
was one of said arguments.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;groups&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>group</span>(<span class='string'>&quot;mode&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;verbose&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;verbose&quot;</span>)
        .<span class='ident'>group</span>(<span class='string'>&quot;mode&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posvals&quot;</span>, <span class='string'>&quot;--debug&quot;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;mode&quot;</span>));</pre>
</div><h4 id='method.groups' class='method'><code>fn <a href='#method.groups' class='fnname'>groups</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the names of multiple <a href="./struct.ArgGroup.html"><code>ArgGroup</code></a>&#39;s the argument belongs to.</p>

<h1 id='examples-25' class='section-header'><a href='#examples-25'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
    .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>)
    .<span class='ident'>groups</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;mode&quot;</span>, <span class='string'>&quot;verbosity&quot;</span>])</pre>

<p>Arguments can be members of multiple groups and then the group checked as if it
was one of said arguments.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;groups&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;debug&quot;</span>)
        .<span class='ident'>groups</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;mode&quot;</span>, <span class='string'>&quot;verbosity&quot;</span>]))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;verbose&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;verbose&quot;</span>)
        .<span class='ident'>groups</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;mode&quot;</span>, <span class='string'>&quot;verbosity&quot;</span>]))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;posvals&quot;</span>, <span class='string'>&quot;--debug&quot;</span>]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;mode&quot;</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;verbosity&quot;</span>));</pre>
</div><h4 id='method.number_of_values' class='method'><code>fn <a href='#method.number_of_values' class='fnname'>number_of_values</a>(self, qty: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies how many values are required to satisfy this argument. For example, if you had a
<code>-f &lt;file&gt;</code> argument where you wanted exactly 3 &#39;files&#39; you would set
<code>.number_of_values(3)</code>, and this argument wouldn&#39;t be satisfied unless the user provided
3 and only 3 values.</p>

<p><strong>NOTE:</strong> Does <em>not</em> require <a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a> to be set. Setting
<a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a> would allow <code>-f &lt;file&gt; &lt;file&gt; &lt;file&gt; -f &lt;file&gt; &lt;file&gt; &lt;file&gt;</code> where
as <em>not</em> setting <a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a> would only allow one occurrence of this argument.</p>

<h1 id='examples-26' class='section-header'><a href='#examples-26'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
    .<span class='ident'>short</span>(<span class='string'>&quot;f&quot;</span>)
    .<span class='ident'>number_of_values</span>(<span class='number'>3</span>)</pre>

<p>Not supplying the correct number of values is an error</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;numvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>number_of_values</span>(<span class='number'>2</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>WrongNumberOfValues</span>);</pre>
</div><h4 id='method.validator' class='method'><code>fn <a href='#method.validator' class='fnname'>validator</a>&lt;F&gt;(self, f: F) -&gt; Self <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(<a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a>&gt; + 'static</span></code></h4>
<div class='docblock'><p>Allows one to perform a custom validation on the argument value. You provide a closure
which accepts a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> value, and return a <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> where the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err(String)</code></a> is a
message displayed to the user.</p>

<p><strong>NOTE:</strong> The error message does <em>not</em> need to contain the <code>error:</code> portion, only the
message.</p>

<p><strong>NOTE:</strong> There is a small performance hit for using validators, as they are implemented
with <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> pointers. And the value to be checked will be allocated an extra time in order
to to be passed to the closure. This performance hit is extremely minimal in the grand
scheme of things.</p>

<h1 id='examples-27' class='section-header'><a href='#examples-27'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>has_at</span>(<span class='ident'>v</span>: <span class='ident'>String</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>(), <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='kw'>if</span> <span class='ident'>v</span>.<span class='ident'>contains</span>(<span class='string'>&quot;@&quot;</span>) { <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(()); }
    <span class='prelude-val'>Err</span>(<span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;The value did not contain the required @ sigil&quot;</span>))
}
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;validators&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>index</span>(<span class='number'>1</span>)
        .<span class='ident'>validator</span>(<span class='ident'>has_at</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;validators&quot;</span>, <span class='string'>&quot;some@file&quot;</span>
    ]);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap</span>().<span class='ident'>value_of</span>(<span class='string'>&quot;file&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;some@file&quot;</span>));</pre>
</div><h4 id='method.max_values' class='method'><code>fn <a href='#method.max_values' class='fnname'>max_values</a>(self, qty: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the <em>maximum</em> number of values are for this argument. For example, if you had a
<code>-f &lt;file&gt;</code> argument where you wanted up to 3 &#39;files&#39; you would set <code>.max_values(3)</code>, and
this argument would be satisfied if the user provided, 1, 2, or 3 values.</p>

<p><strong>NOTE:</strong> This does <em>not</em> implicitly set <a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a>. This is because
<code>-o val -o val</code> is multiple occurrences but a single value and <code>-o val1 val2</code> is a single
occurence with multple values. For positional arguments this <strong>does</strong> set
<a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a> because there is no way to determine the difference between multiple
occurences and multiple values.</p>

<h1 id='examples-28' class='section-header'><a href='#examples-28'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
    .<span class='ident'>short</span>(<span class='string'>&quot;f&quot;</span>)
    .<span class='ident'>max_values</span>(<span class='number'>3</span>)</pre>

<p>Supplying less than the maximum number of values is allowed</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;numvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>max_values</span>(<span class='number'>3</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>());
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>res</span>.<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>files</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;file&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>files</span>, [<span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>]);</pre>

<p>Supplying more than the maximum number of values is an error</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;numvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>max_values</span>(<span class='number'>2</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>TooManyValues</span>);</pre>
</div><h4 id='method.min_values' class='method'><code>fn <a href='#method.min_values' class='fnname'>min_values</a>(self, qty: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the <em>minimum</em> number of values for this argument. For example, if you had a
<code>-f &lt;file&gt;</code> argument where you wanted at least 2 &#39;files&#39; you would set
<code>.min_values(2)</code>, and this argument would be satisfied if the user provided, 2 or more
values.</p>

<p><strong>NOTE:</strong> This does not implicitly set <a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a>. This is because
<code>-o val -o val</code> is multiple occurrences but a single value and <code>-o val1 val2</code> is a single
occurence with multiple values. For positional arguments this <strong>does</strong> set
<a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a> because there is no way to determine the difference between multiple
occurences and multiple values.</p>

<h1 id='examples-29' class='section-header'><a href='#examples-29'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
    .<span class='ident'>short</span>(<span class='string'>&quot;f&quot;</span>)
    .<span class='ident'>min_values</span>(<span class='number'>3</span>)</pre>

<p>Supplying more than the minimum number of values is allowed</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;numvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>min_values</span>(<span class='number'>2</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_ok</span>());
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>res</span>.<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>files</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;file&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>files</span>, [<span class='string'>&quot;file1&quot;</span>, <span class='string'>&quot;file2&quot;</span>, <span class='string'>&quot;file3&quot;</span>]);</pre>

<p>Supplying less than the minimum number of values is an error</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;numvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;file&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>min_values</span>(<span class='number'>2</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;F&quot;</span>))
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;mults&quot;</span>, <span class='string'>&quot;-F&quot;</span>, <span class='string'>&quot;file1&quot;</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>unwrap_err</span>().<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>TooFewValues</span>);</pre>
</div><h4 id='method.use_delimiter' class='method'><code>fn <a href='#method.use_delimiter' class='fnname'>use_delimiter</a>(self, d: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies whether or not an argument should allow grouping of multiple values via a
delimiter. I.e. should <code>--option=val1,val2,val3</code> be parsed as three values (<code>val1</code>, <code>val2</code>,
and <code>val3</code>) or as a single value (<code>val1,val2,val3</code>). Defaults to using <code>,</code> (comma) as the
value delimiter for all arguments that accept values (options and positional arguments)</p>

<p><strong>NOTE:</strong> The default is <code>true</code>. Setting the value to <code>true</code> will reset any previous use of
<a href="./struct.Arg.html#method.value_delimiter"><code>Arg::value_delimiter</code></a> back to the default of <code>,</code> (comma).</p>

<h1 id='examples-30' class='section-header'><a href='#examples-30'>Examples</a></h1>
<p>The following example shows the default behavior.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>delims</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;delims&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;option&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;option&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;delims&quot;</span>,
        <span class='string'>&quot;--option=val1,val2,val3&quot;</span>,
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>delims</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;option&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>delims</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;option&quot;</span>), <span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>delims</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;option&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>(), [<span class='string'>&quot;val1&quot;</span>, <span class='string'>&quot;val2&quot;</span>, <span class='string'>&quot;val3&quot;</span>]);</pre>

<p>The next example shows the difference when turning delimiters off.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>nodelims</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;nodelims&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;option&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;option&quot;</span>)
        .<span class='ident'>use_delimiter</span>(<span class='bool-val'>false</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;nodelims&quot;</span>,
        <span class='string'>&quot;--option=val1,val2,val3&quot;</span>,
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>nodelims</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;option&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>nodelims</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;option&quot;</span>), <span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>nodelims</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;option&quot;</span>).<span class='ident'>unwrap</span>(), <span class='string'>&quot;val1,val2,val3&quot;</span>);</pre>
</div><h4 id='method.require_delimiter' class='method'><code>fn <a href='#method.require_delimiter' class='fnname'>require_delimiter</a>(self, d: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies that <em>multiple values</em> may only be set using the delimiter. This means if an
if an option is encountered, and no delimiter is found, it automatically assumed that no
additional values for that option follow. This is unlike the default, where it is generally
assumed that more values will follow regardless of whether or not a delimiter is used.</p>

<p><strong>NOTE:</strong> The default is <code>false</code>.</p>

<p><strong>NOTE:</strong> It&#39;s a good idea to inform the user that use of a delimiter is required, either
through help text or other means.</p>

<h1 id='examples-31' class='section-header'><a href='#examples-31'>Examples</a></h1>
<p>These examples demonstrate what happens when <code>require_delimiter(true)</code> is used. Notice
everything works in this first example, as we use a delimiter, as expected.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>delims</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;reqdelims&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;opt&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;o&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>require_delimiter</span>(<span class='bool-val'>true</span>))
    <span class='comment'>// Simulate &quot;$ reqdelims -o val1,val2,val3&quot;</span>
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;reqdelims&quot;</span>, <span class='string'>&quot;-o&quot;</span>, <span class='string'>&quot;val1,val2,val3&quot;</span>,
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>delims</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;opt&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>delims</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;opt&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>(), [<span class='string'>&quot;val1&quot;</span>, <span class='string'>&quot;val2&quot;</span>, <span class='string'>&quot;val3&quot;</span>]);</pre>

<p>In this next example, we will <em>not</em> use a delimiter. Notice it&#39;s now an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;reqdelims&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;opt&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;o&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>require_delimiter</span>(<span class='bool-val'>true</span>))
    <span class='comment'>// Simulate &quot;$ reqdelims -o val1 val2 val3&quot;</span>
    .<span class='ident'>get_matches_from_safe</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;reqdelims&quot;</span>, <span class='string'>&quot;-o&quot;</span>, <span class='string'>&quot;val1&quot;</span>, <span class='string'>&quot;val2&quot;</span>, <span class='string'>&quot;val3&quot;</span>,
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>res</span>.<span class='ident'>is_err</span>());
<span class='kw'>let</span> <span class='ident'>err</span> <span class='op'>=</span> <span class='ident'>res</span>.<span class='ident'>unwrap_err</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>err</span>.<span class='ident'>kind</span>, <span class='ident'>ErrorKind</span>::<span class='ident'>UnknownArgument</span>);</pre>

<p>What&#39;s happening is <code>-o</code> is getting <code>val1</code>, and because delimiters are required yet none
were present, it stops parsing <code>-o</code>. At this point it reaches <code>val2</code> and because no
positional arguments have been defined, it&#39;s an error of an unexpected argument.</p>

<p>In this final example, we contrast the above with <code>clap</code>&#39;s default behavior where the above
is <em>not</em> an error.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>delims</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;reqdelims&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;opt&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;o&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>multiple</span>(<span class='bool-val'>true</span>))
    <span class='comment'>// Simulate &quot;$ reqdelims -o val1 val2 val3&quot;</span>
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;reqdelims&quot;</span>, <span class='string'>&quot;-o&quot;</span>, <span class='string'>&quot;val1&quot;</span>, <span class='string'>&quot;val2&quot;</span>, <span class='string'>&quot;val3&quot;</span>,
    ]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>delims</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;opt&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>delims</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;opt&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>(), [<span class='string'>&quot;val1&quot;</span>, <span class='string'>&quot;val2&quot;</span>, <span class='string'>&quot;val3&quot;</span>]);</pre>
</div><h4 id='method.value_delimiter' class='method'><code>fn <a href='#method.value_delimiter' class='fnname'>value_delimiter</a>(self, d: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the separator to use when values are clumped together, defaults to <code>,</code> (comma).</p>

<p><strong>NOTE:</strong> implicitly sets <a href="./struct.Arg.html#method.use_delimiter"><code>Arg::use_delimiter(true)</code></a></p>

<p><strong>NOTE:</strong> implicitly sets <a href="./struct.Arg.html#method.takes_value"><code>Arg::takes_value(true)</code></a></p>

<h1 id='examples-32' class='section-header'><a href='#examples-32'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>app</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;fake&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;c&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>value_delimiter</span>(<span class='string'>&quot;;&quot;</span>));

<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>app</span>.<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
    <span class='string'>&quot;fake&quot;</span>, <span class='string'>&quot;--config=val1;val2;val3&quot;</span>
]);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>values_of</span>(<span class='string'>&quot;config&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>(), [<span class='string'>&quot;val1&quot;</span>, <span class='string'>&quot;val2&quot;</span>, <span class='string'>&quot;val3&quot;</span>])</pre>
</div><h4 id='method.value_names' class='method'><code>fn <a href='#method.value_names' class='fnname'>value_names</a>(self, names: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>&amp;'b <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specify multiple names for values of option arguments. These names are cosmetic only, used
for help and usage strings only. The names are <strong>not</strong> used to access arguments. The values
of the arguments are accessed in numeric order (i.e. if you specify two names <code>one</code> and
<code>two</code> <code>one</code> will be the first matched value, <code>two</code> will be the second).</p>

<p>This setting can be very helpful when describing the type of input the user should be
using, such as <code>FILE</code>, <code>INTERFACE</code>, etc. Although not required, it&#39;s somewhat convention to
use all capital letters for the value name.</p>

<p><strong>Pro Tip:</strong> It may help to use <a href="./struct.Arg.html#method.next_line_help"><code>Arg::next_line_help(true)</code></a> if there are long, or
multiple value names in order to not throw off the help text alignment of all options.</p>

<p><strong>NOTE:</strong> This implicitly sets <a href="./struct.Arg.html#method.number_of_values"><code>Arg::number_of_values</code></a> if the number of value names is
greater than one. I.e. be aware that the number of &quot;names&quot; you set for the values, will be
the <em>exact</em> number of values required to satisfy this argument</p>

<p><strong>NOTE:</strong> implicitly sets <a href="./struct.Arg.html#method.takes_value"><code>Arg::takes_value(true)</code></a></p>

<p><strong>NOTE:</strong> Does <em>not</em> require or imply <a href="./struct.Arg.html#method.multiple"><code>Arg::multiple(true)</code></a>.</p>

<h1 id='examples-33' class='section-header'><a href='#examples-33'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;speed&quot;</span>)
    .<span class='ident'>short</span>(<span class='string'>&quot;s&quot;</span>)
    .<span class='ident'>value_names</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;fast&quot;</span>, <span class='string'>&quot;slow&quot;</span>])</pre>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>app</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;valnames&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;io&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;io-files&quot;</span>)
        .<span class='ident'>value_names</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;INFILE&quot;</span>, <span class='string'>&quot;OUTFILE&quot;</span>]))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;valnames&quot;</span>, <span class='string'>&quot;--help&quot;</span>
    ]);</pre>

<p>Running the above program produces the following output</p>

<pre><code class="language-notrust">valnames

USAGE:
   valnames [FLAGS] [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    --io-files &lt;INFILE&gt; &lt;OUTFILE&gt;    Some help text
</code></pre>
</div><h4 id='method.value_name' class='method'><code>fn <a href='#method.value_name' class='fnname'>value_name</a>(self, name: &amp;'b <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the name for value of <a href="./struct.Arg.html#method.takes_value">option</a> or <a href="./struct.Arg.html#method.index">positional</a> arguments inside of help
documentation. This name is cosmetic only, the name is <strong>not</strong> used to access arguments.
This setting can be very helpful when describing the type of input the user should be
using, such as <code>FILE</code>, <code>INTERFACE</code>, etc. Although not required, it&#39;s somewhat convention to
use all capital letters for the value name.</p>

<p><strong>NOTE:</strong> implicitly sets <a href="./struct.Arg.html#method.takes_value"><code>Arg::takes_value(true)</code></a></p>

<h1 id='examples-34' class='section-header'><a href='#examples-34'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;cfg&quot;</span>)
    .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
    .<span class='ident'>value_name</span>(<span class='string'>&quot;FILE&quot;</span>)</pre>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>app</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;valnames&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
        .<span class='ident'>value_name</span>(<span class='string'>&quot;FILE&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;valnames&quot;</span>, <span class='string'>&quot;--help&quot;</span>
    ]);</pre>

<p>Running the above program produces the following output</p>

<pre><code class="language-notrust">valnames

USAGE:
   valnames [FLAGS] [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    --config &lt;FILE&gt;     Some help text
</code></pre>
</div><h4 id='method.default_value' class='method'><code>fn <a href='#method.default_value' class='fnname'>default_value</a>(self, val: &amp;'a <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Specifies the value of the argument when <em>not</em> specified at runtime.</p>

<p><strong>NOTE:</strong> If the user <em>does not</em> use this argument at runtime, <a href="/struct.ArgMatches.html#method.occurrences_of"><code>ArgMatches::occurrences_of</code></a>
will return <code>0</code> even though the <a href="./struct.ArgMatches.html#method.value_of"><code>ArgMatches::value_of</code></a> will return the default specified.</p>

<p><strong>NOTE:</strong> If the user <em>does not</em> use this argument at runtime <a href="/struct.ArgMatches.html#method.is_present"><code>ArgMatches::is_present</code></a> will
still return <code>true</code>. If you wish to determine whether the argument was used at runtime or
not, consider <a href="/struct.ArgMatches.html#method.occurrences_of"><code>ArgMatches::occurrences_of</code></a> which will return <code>0</code> if the argument was <em>not</em>
used at runtmie.</p>

<p><strong>NOTE:</strong> This implicitly sets <a href="/struct.Arg.html#method.takes_value"><code>Arg::takes_value(true)</code></a>.</p>

<h1 id='examples-35' class='section-header'><a href='#examples-35'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;defvals&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;opt&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;myopt&quot;</span>)
        .<span class='ident'>default_value</span>(<span class='string'>&quot;myval&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;defvals&quot;</span>
    ]);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;opt&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;myval&quot;</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;opt&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>m</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;opt&quot;</span>), <span class='number'>0</span>);</pre>
</div><h4 id='method.next_line_help' class='method'><code>fn <a href='#method.next_line_help' class='fnname'>next_line_help</a>(self, nlh: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; Self</code></h4>
<div class='docblock'><p>When set to <code>true</code> the help string will be displayed on the line after the argument and
indented once. This can be helpful for arguments with very long or complex help messages.
This can also be helpful for arguments with very long flag names, or many/long value names.</p>

<p><strong>NOTE:</strong> To apply this setting to all arguments consider using
<a href="./enum.AppSettings.html#variant.NextLineHelp"><code>AppSettings::NextLineHelp</code></a></p>

<h1 id='examples-36' class='section-header'><a href='#examples-36'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;nlh&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;opt&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;long-option-flag&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;o&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>value_names</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;value1&quot;</span>, <span class='string'>&quot;value2&quot;</span>])
        .<span class='ident'>help</span>(<span class='string'>&quot;Some really long help and complex{n}\
               help that makes more sense to be{n}\
               on a line after the option&quot;</span>)
        .<span class='ident'>next_line_help</span>(<span class='bool-val'>true</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;nlh&quot;</span>, <span class='string'>&quot;--help&quot;</span>
    ]);</pre>

<p>The above example displays the following help message</p>

<pre><code class="language-notrust">nlh

USAGE:
    nlh [FLAGS] [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -o, --long-option-flag &lt;value1&gt; &lt;value2&gt;
        Some really long help and complex
        help that makes more sense to be
        on a line after the option
</code></pre>
</div><h4 id='method.display_order' class='method'><code>fn <a href='#method.display_order' class='fnname'>display_order</a>(self, ord: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Allows custom ordering of args within the help message. Args with a lower value will be
displayed first in the help message. This is helpful when one would like to emphasise
frequently used args, or prioritize those towards the top of the list. Duplicate values
<strong>are</strong> allowed. Args with duplicate display orders will be displayed in alphabetical
order.</p>

<p><strong>NOTE:</strong> The default is 999 for all arguments.</p>

<p><strong>NOTE:</strong> This setting is ignored for <a href="./struct.Arg.html#method.index">positional arguments</a> which are always displayed in
<a href="./struct.Arg.html#method.index">index</a> order.</p>

<h1 id='examples-37' class='section-header'><a href='#examples-37'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;cust-ord&quot;</span>)
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;a&quot;</span>) <span class='comment'>// Typically args are grouped alphabetically by name.</span>
                             <span class='comment'>// Args without a display_order have a value of 999 and are</span>
                             <span class='comment'>// displayed alphabetically with all other 999 valued args.</span>
        .<span class='ident'>long</span>(<span class='string'>&quot;long-option&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;o&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>help</span>(<span class='string'>&quot;Some help and text&quot;</span>))
    .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;b&quot;</span>)
        .<span class='ident'>long</span>(<span class='string'>&quot;other-option&quot;</span>)
        .<span class='ident'>short</span>(<span class='string'>&quot;O&quot;</span>)
        .<span class='ident'>takes_value</span>(<span class='bool-val'>true</span>)
        .<span class='ident'>display_order</span>(<span class='number'>1</span>)   <span class='comment'>// In order to force this arg to appear *first*</span>
                            <span class='comment'>// all we have to do is give it a value lower than 999.</span>
                            <span class='comment'>// Any other args with a value of 1 will be displayed</span>
                            <span class='comment'>// alphabetically with this one...then 2 values, then 3, etc.</span>
        .<span class='ident'>help</span>(<span class='string'>&quot;I should be first!&quot;</span>))
    .<span class='ident'>get_matches_from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='string'>&quot;cust-ord&quot;</span>, <span class='string'>&quot;--help&quot;</span>
    ]);</pre>

<p>The above example displays the following help message</p>

<pre><code class="language-notrust">cust-ord

USAGE:
    cust-ord [FLAGS] [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -O, --other-option &lt;b&gt;    I should be first!
    -o, --long-option &lt;a&gt;     Some help and text
</code></pre>
</div><h4 id='method.is_set' class='method'><code>fn <a href='#method.is_set' class='fnname'>is_set</a>(&amp;self, s: <a class='enum' href='../clap/enum.ArgSettings.html' title='clap::ArgSettings'>ArgSettings</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Checks if one of the <a href="./enum.ArgSettings.html"><code>ArgSettings</code></a> settings is set for the argument</p>
</div><h4 id='method.set' class='method'><code>fn <a href='#method.set' class='fnname'>set</a>(self, s: <a class='enum' href='../clap/enum.ArgSettings.html' title='clap::ArgSettings'>ArgSettings</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Sets one of the <a href="./enum.ArgSettings.html"><code>ArgSettings</code></a> settings for the argument</p>
</div><h4 id='method.unset' class='method'><code>fn <a href='#method.unset' class='fnname'>unset</a>(self, s: <a class='enum' href='../clap/enum.ArgSettings.html' title='clap::ArgSettings'>ArgSettings</a>) -&gt; Self</code></h4>
<div class='docblock'><p>Unsets one of the <a href="./enum.ArgSettings.html"><code>ArgSettings</code></a> settings for the argument</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl&lt;'a,&nbsp;'b&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html' title='core::default::Default'>Default</a> for <a class='struct' href='../clap/struct.Arg.html' title='clap::Arg'>Arg</a>&lt;'a,&nbsp;'b&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-3036' class='srclink' href='../src/clap/args/arg.rs.html#80-105' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.default' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; Self</code></h4>
<div class='docblock'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;'a,&nbsp;'b,&nbsp;'z&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html' title='core::convert::From'>From</a>&lt;&amp;'z <a class='struct' href='../clap/struct.Arg.html' title='clap::Arg'>Arg</a>&lt;'a,&nbsp;'b&gt;&gt; for <a class='struct' href='../clap/struct.Arg.html' title='clap::Arg'>Arg</a>&lt;'a,&nbsp;'b&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-3217' class='srclink' href='../src/clap/args/arg.rs.html#2356-2381' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.from' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(a: &amp;'z <a class='struct' href='../clap/struct.Arg.html' title='clap::Arg'>Arg</a>&lt;'a,&nbsp;'b&gt;) -&gt; Self</code></h4>
<div class='docblock'><p>Performs the conversion.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;'a,&nbsp;'b&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../clap/struct.Arg.html' title='clap::Arg'>Arg</a>&lt;'a,&nbsp;'b&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a id='src-3223' class='srclink' href='../src/clap/args/arg.rs.html#2383-2408' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; Self</code></h4>
<div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "clap";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>